<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Git Book 笔记 | Lay</title>
    <meta name="generator" content="VuePress 1.5.1">
    
    <meta name="description" content="lay的博客">
    <link rel="preload" href="/blog/assets/css/0.styles.d6b61f4e.css" as="style"><link rel="preload" href="/blog/assets/js/app.5a94629e.js" as="script"><link rel="preload" href="/blog/assets/js/3.98e048c5.js" as="script"><link rel="preload" href="/blog/assets/js/19.bdb46fb7.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.874a4e8d.js"><link rel="prefetch" href="/blog/assets/js/11.e02e5f6f.js"><link rel="prefetch" href="/blog/assets/js/12.475a8e4d.js"><link rel="prefetch" href="/blog/assets/js/13.fc34cf78.js"><link rel="prefetch" href="/blog/assets/js/14.4ee8f749.js"><link rel="prefetch" href="/blog/assets/js/15.95e90913.js"><link rel="prefetch" href="/blog/assets/js/16.c4400d0c.js"><link rel="prefetch" href="/blog/assets/js/17.c86b685b.js"><link rel="prefetch" href="/blog/assets/js/18.b8ca17d0.js"><link rel="prefetch" href="/blog/assets/js/20.126d2240.js"><link rel="prefetch" href="/blog/assets/js/21.555cd8fd.js"><link rel="prefetch" href="/blog/assets/js/22.4489c745.js"><link rel="prefetch" href="/blog/assets/js/23.f397278c.js"><link rel="prefetch" href="/blog/assets/js/24.09a4cbda.js"><link rel="prefetch" href="/blog/assets/js/25.e00936ab.js"><link rel="prefetch" href="/blog/assets/js/26.f5c71e6a.js"><link rel="prefetch" href="/blog/assets/js/27.9c8b2065.js"><link rel="prefetch" href="/blog/assets/js/28.ac3fe6e4.js"><link rel="prefetch" href="/blog/assets/js/29.37502bac.js"><link rel="prefetch" href="/blog/assets/js/4.a17d00ef.js"><link rel="prefetch" href="/blog/assets/js/5.08446a69.js"><link rel="prefetch" href="/blog/assets/js/6.f7bf75d2.js"><link rel="prefetch" href="/blog/assets/js/7.b04c5afc.js"><link rel="prefetch" href="/blog/assets/js/8.828d5f15.js"><link rel="prefetch" href="/blog/assets/js/9.c47a04a3.js"><link rel="prefetch" href="/blog/assets/js/vendors~flowchart.1cd746f1.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.d6b61f4e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">Lay</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/technology/BE/Java 笔记.html" class="nav-link">
  技术分享
</a></div><div class="nav-item"><a href="/blog/practice/Blog/vuepress.html" class="nav-link">
  实战分享
</a></div><div class="nav-item"><a href="/blog/notes/Typescript/TemplateLiteralTypes.html" class="nav-link">
  烂笔头
</a></div> <a href="https://github.com/lei4519/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/technology/BE/Java 笔记.html" class="nav-link">
  技术分享
</a></div><div class="nav-item"><a href="/blog/practice/Blog/vuepress.html" class="nav-link">
  实战分享
</a></div><div class="nav-item"><a href="/blog/notes/Typescript/TemplateLiteralTypes.html" class="nav-link">
  烂笔头
</a></div> <a href="https://github.com/lei4519/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>BE</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Chrome</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Electron</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Git</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/technology/Git/Git book 笔记.html" class="active sidebar-link">Git Book 笔记</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/technology/Git/Git book 笔记.html#git-svn区别" class="sidebar-link">Git &amp; Svn区别</a></li><li class="sidebar-sub-header"><a href="/blog/technology/Git/Git book 笔记.html#git的设计目标（特点）" class="sidebar-link">Git的设计目标（特点）</a></li><li class="sidebar-sub-header"><a href="/blog/technology/Git/Git book 笔记.html#git-基本工作原理，如何进行版本控制？" class="sidebar-link">Git 基本工作原理，如何进行版本控制？</a></li><li class="sidebar-sub-header"><a href="/blog/technology/Git/Git book 笔记.html#运程仓库" class="sidebar-link">运程仓库</a></li><li class="sidebar-sub-header"><a href="/blog/technology/Git/Git book 笔记.html#打标签" class="sidebar-link">打标签</a></li><li class="sidebar-sub-header"><a href="/blog/technology/Git/Git book 笔记.html#实际开发流程" class="sidebar-link">实际开发流程</a></li><li class="sidebar-sub-header"><a href="/blog/technology/Git/Git book 笔记.html#commit-message-规范" class="sidebar-link">commit message 规范</a></li><li class="sidebar-sub-header"><a href="/blog/technology/Git/Git book 笔记.html#配置commit提示工具" class="sidebar-link">配置Commit提示工具</a></li><li class="sidebar-sub-header"><a href="/blog/technology/Git/Git book 笔记.html#为项目加入提交信息检查" class="sidebar-link">为项目加入提交信息检查</a></li><li class="sidebar-sub-header"><a href="/blog/technology/Git/Git book 笔记.html#为项目增加提交时eslint检查和修复" class="sidebar-link">为项目增加提交时Eslint检查和修复</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTTP</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>MiniProgram</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Node</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Web</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="git-book-笔记"><a href="#git-book-笔记" class="header-anchor">#</a> Git Book 笔记</h1> <ol><li>Git &amp; Svn 差异点，理解 Git 工作模式</li> <li>Git 的基本原理，如果进行版本控制，分支是什么？</li> <li>模拟实际开发场景</li> <li>梳理日常开发时的 Git 使用流程</li> <li>使用 Vscode 对第三步进行实操</li></ol> <h2 id="git-svn区别"><a href="#git-svn区别" class="header-anchor">#</a> Git &amp; Svn区别</h2> <h3 id="svn-集中化版本控制系统"><a href="#svn-集中化版本控制系统" class="header-anchor">#</a> Svn: 集中化版本控制系统</h3> <img src="https://git-scm.com/book/en/v2/images/centralized.png" alt="集中化的版本控制图解" style="zoom:50%;"> <h3 id="git-分布式版本控制系统"><a href="#git-分布式版本控制系统" class="header-anchor">#</a> Git: 分布式版本控制系统</h3> <img src="https://git-scm.com/book/en/v2/images/distributed.png" alt="分布式版本控制图解" style="zoom:50%;"> <ul><li>拉取项目命令差异点
<ul><li><code>svn checkout http://...</code></li> <li><code>git clone http://...</code></li></ul></li></ul> <h3 id="版本库"><a href="#版本库" class="header-anchor">#</a> 版本库</h3> <ul><li>工作（项目）目录有一个隐藏目录<code>.git</code>，这个就是Git的版本库。</li></ul> <h3 id="本地操作"><a href="#本地操作" class="header-anchor">#</a> 本地操作</h3> <ul><li>远程仓库同步版本库</li> <li>版本控制操作都是本地操作</li> <li>查看 log、回退版本、提交版本、合并分支、创建分支</li> <li>分功能点进行提交，确保后续开发不会影响已开发完成的功能，快速定位 功能Bug。
<ul><li>主题色功能实现 commit</li> <li>历史记录功能实现 commit</li> <li>拖拽区功能实现 commit</li></ul></li> <li>Svn commit 依赖于网络和 VPN</li></ul> <h2 id="git的设计目标（特点）"><a href="#git的设计目标（特点）" class="header-anchor">#</a> Git的设计目标（特点）</h2> <blockquote><p>Linus 用来管理 Linux 源码。（Linus自己用 C 语言花了两周时间写的）</p> <p>Linux 系统：开源项目，由全世界的热心志愿者共同完成的。</p></blockquote> <ul><li>速度</li> <li>简单的设计</li> <li>完全分布式</li> <li>有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</li> <li><strong>对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</strong> <ul><li>分支工作流</li></ul></li></ul> <h2 id="git-基本工作原理，如何进行版本控制？"><a href="#git-基本工作原理，如何进行版本控制？" class="header-anchor">#</a> Git 基本工作原理，如何进行版本控制？</h2> <blockquote><p>Git对每一次提交直接记录文件快照，而非差异比较</p></blockquote> <h4 id="svn-记录差异"><a href="#svn-记录差异" class="header-anchor">#</a> Svn <strong>记录差异</strong></h4> <ul><li>存储的信息是一组基本文件和每个文件每次提交所产生的差异</li></ul> <p><img src="https://git-scm.com/book/en/v2/images/deltas.png" alt="存储每个文件与初始版本的差异。"></p> <h4 id="git-记录快照"><a href="#git-记录快照" class="header-anchor">#</a> Git 记录快照</h4> <ul><li>对提交的文件创建一个快照（blob 对象）</li></ul> <p><img src="https://git-scm.com/book/en/v2/images/snapshots.png" alt="Git 存储项目随时间改变的快照。"></p> <h3 id="快照的创建"><a href="#快照的创建" class="header-anchor">#</a> 快照的创建</h3> <h4 id="首次提交"><a href="#首次提交" class="header-anchor">#</a> 首次提交</h4> <ul><li>假设有一个新的 git 仓库，我们来创建三个新的文件：README、test.rb、LICENSE，并将这三个文件提交到版本库。</li></ul> <div class="language-console extra-class"><pre class="language-text"><code>$ touch README test.rb LICENSE
$ git add README test.rb LICENSE
$ git commit -m 'The initial commit of my project'   git cz
</code></pre></div><ul><li><p><code>git add</code>  暂存操作：为工作区中已修改的文件创建快照</p> <ul><li>暂存操作会为每一个修改文件计算校验和（SHA-1 算法），然后会把当前版本的文件快照保存到 Git 仓库中，最终将校验和（索引）加入到暂存区等待提交</li> <li>暂存区：暂时存储文件快照，并未提交至版本库</li> <li>场景：某一个功能开发到了 60%，觉得有另一种实现方案想去尝试。但是 60%的功能不值得我们做一次提交记录，如果直接尝试新的方案，等发现方案不可行的时候，需要自己一步步的回退代码。暂存区可以暂时存储这 60%的代码，一旦发现新方案不可行，直接将新方案的修改进行全部撤回即可。</li></ul></li> <li><p><code>git commit</code> 提交版本库</p> <ul><li><p>创建树对象，记录着目录结构和文件快照索引（可以理解为整个项目的快照）</p></li> <li><p>创建提交对象，保存<strong>树</strong>对象和所有的提交信息（作者姓名、邮箱、提交信息）</p> <p><img src="https://git-scm.com/book/en/v2/images/commit-and-tree.png" alt="首次提交对象及其树结构。"></p></li></ul></li></ul> <h4 id="再次提交"><a href="#再次提交" class="header-anchor">#</a> 再次提交</h4> <ul><li>重复上述操作，这次的提交对象会包含一个指向上次提交对象的指针</li></ul> <p><img src="https://git-scm.com/book/en/v2/images/commits-and-parents.png" alt="提交对象及其父对象。"></p> <h3 id="分支的原理"><a href="#分支的原理" class="header-anchor">#</a> 分支的原理</h3> <ul><li>Git 分支的本质，记录了某一个提交对象索引（校验和）的文件。</li> <li><code>.git/refs/heads</code></li> <li>Git 初始化时会自动创建一个默认分支 <code>master</code>，<code>.git/refs/heads/master</code></li> <li>每次提交时当前分支会自动指向最新的提交对象。</li></ul> <p>![image-20200912150803725](/Users/lay/Library/Application Support/typora-user-images/image-20200912150803725.png)</p> <h4 id="分支创建"><a href="#分支创建" class="header-anchor">#</a> 分支创建</h4> <div class="language-console extra-class"><pre class="language-text"><code>$ git branch testing
</code></pre></div><ul><li>在<code>.git/refs/heads</code>中创建了<code>testing</code>文件</li> <li>通过<code>HEAD</code> 的指针区分所在分支，<code>HEAD</code> 总是指向当前所在的分支</li> <li><code>git branch</code> 命令仅仅 <strong>创建</strong> 一个新分支，并不会自动切换到新分支中去</li></ul> <p><img src="https://git-scm.com/book/en/v2/images/head-to-master.png" alt="HEAD 指向当前所在的分支。"></p> <h4 id="分支切换"><a href="#分支切换" class="header-anchor">#</a> 分支切换</h4> <div class="language-console extra-class"><pre class="language-text"><code>$ git checkout testing
</code></pre></div><ul><li><code>HEAD</code> 就指向 <code>testing</code> 分支</li></ul> <p><img src="https://git-scm.com/book/en/v2/images/head-to-testing.png" alt="HEAD 指向当前所在的分支。"></p> <h4 id="分支总结"><a href="#分支总结" class="header-anchor">#</a> 分支总结</h4> <ul><li><p>Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符）</p></li> <li><p>其他大多数版本控制系统在创建分支时，需要将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这个过程所需时间的长短，完全取决于项目的规模。</p></li> <li><p>而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以在分支合并时也是同样的简单和高效。</p></li> <li><p>这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。</p></li></ul> <h3 id="实际场景模拟"><a href="#实际场景模拟" class="header-anchor">#</a> 实际场景模拟</h3> <ul><li>marset 分支：线上分支</li> <li>iss53分支：开发分支</li> <li>起点：项目1.0版本开发测试完成，将开发分支的代码合并到主分支上，部署上线</li></ul> <p><img src="https://git-scm.com/book/en/v2/images/basic-branching-2.png" alt="创建一个新分支指针。"></p> <ul><li><p>开发2.0 版本，并进行一些功能提交，线上版本依旧指向发版时的提交对象</p> <p><img src="https://git-scm.com/book/en/v2/images/basic-branching-3.png" alt=" 分支随着工作的进展向前推进。"></p></li> <li><p>线上版本紧急 BUG</p> <ol><li><p>切换回 <code>master</code> 分支</p> <ul><li>当前开发分支工作目录和暂存区里还有没被提交的修改，这些改动可能会和主分支产生冲突，从而阻止 Git 切换到主分支。</li> <li>切换时需要将修改进行暂存操作<code>git stash</code>或者提交操作<code>git commit</code></li> <li>永远不会在 <code>master</code> 分支中进行代码开发， <code>master</code> 分支的代码都是合并的别的分支，以此保证 <code>master</code> 分支的稳定性（线上版本的稳定性）</li></ul></li> <li><p>新建紧急修复<code>hotfix</code>分支，在该分支上工作直到问题解决，并提交修改。</p> <p><img src="https://git-scm.com/book/en/v2/images/basic-branching-4.png" alt="基于  分支的紧急问题分支（hotfix branch）。"></p></li> <li><p><code>master</code> 合并 <code>hotfix</code> 分支，测试部署上线</p> <div class="language-console extra-class"><pre class="language-text"><code>$ git checkout master
$ git merge hotfix
Fast-forward
</code></pre></div><ul><li>快进（Fast-forward）
<ul><li>要合并的分支所指向的提交对象是你所在分支的提交对象的直接后继， Git 会直接将指针向前移动，因为这种情况下的合并操作没有需要解决的分歧</li></ul></li></ul> <p><img src="https://git-scm.com/book/en/v2/images/basic-branching-5.png" alt=" 被快进到 。"></p></li> <li><p>删除 <code>hotfix</code> 分支，因为我们已经不再需要它了 ——  <code>master</code> 分支已经指向了同一个位置</p> <div class="language-console extra-class"><pre class="language-text"><code>$ git branch -d hotfix
</code></pre></div></li> <li><p>回到开发分支继续工作</p> <ul><li><code>hotfix</code> 分支所做的修改，并没有合并到开发分支上</li></ul></li></ol></li></ul> <ol><li><p>使用 <code>git merge master</code> 命令将 <code>master</code> 分支合并入 开发分支（推荐）</p></li> <li><p>等到 开发分支开发完成，再将其合并回 <code>master</code> 分支</p></li></ol> <ul><li>以上两种操作，在 git 的使用上没有区别，都是合并操作。</li></ul> <p><img src="https://git-scm.com/book/en/v2/images/basic-branching-6.png" alt="继续在  分支上的工作。"></p> <ol start="6"><li><p>2.0开发测试完成，将开发分支的代码合并到主分支上，部署上线</p> <div class="language-console extra-class"><pre class="language-text"><code>  $ git checkout master
  $ git merge iss53
  Merge made by the 'recursive' strategy. 通过“递归”策略进行合并。
</code></pre></div><ul><li><code>master</code> 分支所在提交对象并不是 <code>iss53</code> 分支所在提交对象的直接祖先，Git 会使用两个分支的末端所指的快照（<code>C4</code> 和 <code>C5</code>）以及这两个分支的公共祖先（<code>C2</code>），做一个三方合并</li></ul> <p><img src="https://git-scm.com/book/en/v2/images/basic-merging-1.png" alt="一次典型合并中所用到的三个快照。"></p> <ul><li><p>Git 会将合并的结果做了一个新的快照并且自动创建一个新的提交指向它。</p></li> <li><p>这种提交被称为合并提交，因为他不止有一个父提交对象。</p> <p><img src="https://git-scm.com/book/en/v2/images/basic-merging-2.png" alt="一个合并提交。"></p></li></ul></li></ol> <h4 id="合并冲突"><a href="#合并冲突" class="header-anchor">#</a> 合并冲突</h4> <ul><li><p>如果我们在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。</p></li> <li><p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。</p></li> <li><p>确定之前有冲突的的文件都已经暂存了，输入 <code>git commit</code> 来完成合并提交。 默认情况下提交信息看起来像下面这个样子：</p> <div class="language-console extra-class"><pre class="language-text"><code>Merge branch 'iss53'

Conflicts:
    index.html
#
# It looks like you may be committing a merge.
# If this is not correct, please remove the file
#	.git/MERGE_HEAD
# and try again.


# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# All conflicts fixed but you are still merging.
#
# Changes to be committed:
#	modified:   index.html
#
</code></pre></div></li> <li><p>如果你觉得上述的信息不够充分，不能完全体现分支合并的过程，你可以修改上述信息， 添加一些细节给未来检视这个合并的读者一些帮助，告诉他们你是如何解决合并冲突的，以及理由是什么。</p></li></ul> <h4 id="中断一次合并"><a href="#中断一次合并" class="header-anchor">#</a> 中断一次合并</h4> <ul><li><p>我们可能不想处理冲突这种情况，可以通过 <code>git merge --abort</code> 来简单地退出合并</p> <div class="language-console extra-class"><pre class="language-text"><code>$ git merge --abort
</code></pre></div><ul><li><code>git merge --abort</code> 选项会尝试恢复到运行合并前的状态。</li> <li>合并前确保工作目录中的修改都被提交或暂存。不然此命令会导致那些未被保存的修改也被恢复到修改之前的状态。</li></ul></li></ul> <h4 id="忽略空白"><a href="#忽略空白" class="header-anchor">#</a> 忽略空白</h4> <ul><li>如果一次合并中有大量关于空白的问题，你可以直接中止它并重做一次，这次带上以下参数之一
<ul><li><code>-Xignore-all-space whitespace</code>：在比较行时 <strong>完全忽略</strong> 空白修改</li> <li><code>-Xignore-space-change whitespace</code> ：将一个空白符与多个连续的空白字符视作等价的</li> <li>如果你的团队中的某个人可能不小心重新格式化空格为制表符或者相反的操作，这会是一个救命稻草</li></ul></li></ul> <h4 id="变基"><a href="#变基" class="header-anchor">#</a> 变基</h4> <ul><li>和 <code>merge</code>一样，用来合并分支</li> <li>合并方案是：将当前分支的所有提交操作，在变基分支上重新执行一遍。</li> <li>需要合理使用，否则会导致别人提交的代码丢失。</li> <li><code>merge</code>合并时会产生很多无用的 Merge 信息，尤其是多分支开发合并时，时间长了之后整个项目提交信息会非常杂乱。</li> <li>历史记录清晰，看起来就像是在一个分支中开发的代码。方便版本回退和 bug 追查。</li> <li>黄金法则：在本地分支中对使用变基来更新线上分支代码。</li> <li>大多数公司不使用变基，只是用合并
<ul><li>merge 可以实现结果，不在乎日志是否杂乱。</li> <li>变基概念不好理解，在错误的工作流上使用，会导致别人的工作成果完全丢失。</li></ul></li></ul> <h2 id="运程仓库"><a href="#运程仓库" class="header-anchor">#</a> 运程仓库</h2> <ul><li><p>下载远程仓库</p> <ol><li><p><code>git clone 仓库地址</code></p></li> <li><p>本地初始化 git 仓库</p></li></ol> <div class="language-console extra-class"><pre class="language-text"><code>$ git init
$ git add .
$ git commit -m 'initial project version'
$ git remote add origin git@github.com
$ git push -u origin master
</code></pre></div></li> <li><p><code>git pull</code>拉取远程仓库代码</p></li> <li><p><code>git push</code>推送本地仓库至远程仓库</p></li></ul> <h3 id="分支开发工作流"><a href="#分支开发工作流" class="header-anchor">#</a> 分支开发工作流</h3> <ul><li><p><code>master</code>线上分支：绝对稳定，此版本代码可以随时发布线上，总是合并<code>test</code>测试分支或紧急修复分支代码。</p></li> <li><p><code>test</code>测试分支：提交测试线的代码，总是合并<code>develop</code>测试分支代码。</p></li> <li><p><code>develop</code>开发分支：共享分支，总是合并本地分支代码。</p></li> <li><p>临时、修复、功能分支：本地分支，各功能开发，开发完成合并入开发分支。</p> <ul><li>三个线上分支总是在合并代码，不要直接在这三个分支上进行代码开发。</li></ul> <p><img src="https://git-scm.com/book/en/v2/images/lr-branches-2.png" alt="趋于稳定分支的工作流（“silo”）视图。"></p></li></ul> <h2 id="打标签"><a href="#打标签" class="header-anchor">#</a> 打标签</h2> <ul><li>提交对象的索引是 hash 值，不容易记录，标签就是给提交对象定义个别名。</li> <li><code>git tag &lt;tagname&gt;</code>给当前分支打标签，也可以在后面指定一个commit id，给对应的提交对象打标签。</li> <li><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息。</li> <li>命令<code>git tag</code>可以查看所有标签。</li> <li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签。</li> <li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签。</li> <li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签。</li> <li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li></ul> <h2 id="实际开发流程"><a href="#实际开发流程" class="header-anchor">#</a> 实际开发流程</h2> <ol><li><p>使用<code>git clone</code>下载仓库</p></li> <li><p>基于<code>develop</code>分支创建本地分支，开发过程中针对每个功能点进行提交记录。</p></li> <li><p>开发完成后：</p> <ol><li>切换至开发分支，使用<code>git pull</code>，拉取开发分支最新代码。</li> <li>切换至本地分支，并确保本地分支的代码已全部提交或暂存，这使得我们变基过程中可以随时变基过程中所尝试的所有事情。</li> <li>使用<code>git rebase develop</code>合并开发分支的代码，如有代码冲突，解决后需要重新提交合并对象。</li> <li>切换至开发分支，使用<code>git merge</code>合并本地分支，使用<code>git push</code>推送远程仓库。</li></ol></li> <li><p>切换至测试分支，使用<code>git pull</code>拉取最新代码。</p></li> <li><p>使用<code>git merge develop</code>合并开发分支代码，使用<code>git push</code>推送远程仓库，部署测试。</p></li> <li><p>测试完成，切换至<code>master</code>分支，使用<code>git pull</code>拉取最新代码。</p></li> <li><p>使用<code>git merge test</code>合并测试分支代码，使用<code>git push</code>推送远程仓库，部署上线。</p></li> <li><p>需要修复紧急线上 bug，在<code>master</code>分支新建紧急修复分支，修复问题直到完成。</p></li> <li><p>使用<code>master</code>分支合并紧急修复分支，推送远程仓库并部署。</p></li> <li><p>在紧急修复分支执行第 3 步操作。将代码同步至开发分支。</p></li></ol> <blockquote><p>以上操作只会在<code>git rebase</code>时有可能会遇到代码冲突。所以上述所有 <code>merge</code> 操作都是快进操作。</p></blockquote> <blockquote><p>git rebase -i 可以修改提交记录，具体可以查看官网教程 - 重写历史。应该只对本地分支进行操作。</p></blockquote> <h2 id="commit-message-规范"><a href="#commit-message-规范" class="header-anchor">#</a> commit message 规范</h2> <blockquote><p>Commit message一般包括三部分：Header、Body和Footer。</p></blockquote> <h3 id="header"><a href="#header" class="header-anchor">#</a> Header</h3> <div class="language- extra-class"><pre class="language-text"><code>type(scope):subject
feat(表格): 增加表格下载功能
</code></pre></div><ul><li>type：用于说明commit的类别，规定为如下几种
<ul><li>feat：新增功能；</li> <li>fix：修复bug；</li> <li>docs：修改文档；</li> <li>refactor：代码重构，未新增任何功能和修复任何bug；</li> <li>build：改变构建流程，新增依赖库、工具等（例如webpack修改）；</li> <li>style：仅仅修改了空格、缩进等，不改变代码逻辑；</li> <li>perf：改善性能和体现的修改；</li> <li>chore：非src和test的修改；</li> <li>test：测试用例的修改；</li> <li>ci：自动化流程配置修改；</li> <li>revert：回滚到上一个版本；</li></ul></li> <li>scope：【可选】用于说明commit的影响范围</li> <li>subject：commit的简要说明，尽量简短</li></ul> <h3 id="body"><a href="#body" class="header-anchor">#</a> Body</h3> <p>对本次commit的详细描述，可分多行</p> <h3 id="footer"><a href="#footer" class="header-anchor">#</a> Footer</h3> <ul><li>不兼容变动：需要描述相关信息</li> <li>关闭指定Issue：输入Issue信息</li></ul> <h2 id="配置commit提示工具"><a href="#配置commit提示工具" class="header-anchor">#</a> 配置Commit提示工具</h2> <p>首先，全局安装工具：</p> <div class="language- extra-class"><pre class="language-text"><code>cnpm install commitizen cz-conventional-changelog-chinese -g
</code></pre></div><p>生成配置文件：</p> <div class="language- extra-class"><pre class="language-text"><code>echo '{ &quot;path&quot;: &quot;cz-conventional-changelog-chinese&quot; }' &gt; ~/.czrc
</code></pre></div><p>提交时使用<code>git cz</code>代替<code>git commit</code></p> <p>⚠️注意要使用命令行进行代码提交，不要再使用vscode中的Git提交功能(这个还是 <code>git commit</code>)</p> <h2 id="为项目加入提交信息检查"><a href="#为项目加入提交信息检查" class="header-anchor">#</a> 为项目加入提交信息检查</h2> <ul><li><p>每次提交版本时自动检查提交信息是否符合规范</p> <ol><li>安装依赖</li></ol> <div class="language- extra-class"><pre class="language-text"><code>cnpm install --save-dev @commitlint/config-conventional @commitlint/cli husky
</code></pre></div><ol start="2"><li><p>在项目根目录执行，生成配置文件</p> <div class="language- extra-class"><pre class="language-text"><code>echo 'module.exports = {
  extends: [&quot;@commitlint/config-conventional&quot;],
  rules: {
    &quot;type-enum&quot;: [
      2,
      &quot;always&quot;,
      [
        &quot;feat&quot;,
        &quot;fix&quot;,
        &quot;docs&quot;,
        &quot;refactor&quot;,
        &quot;build&quot;,
        &quot;style&quot;,
        &quot;perf&quot;,
        &quot;chore&quot;,
        &quot;deps&quot;,
        &quot;test&quot;,
        &quot;ci&quot;,
        &quot;revert&quot;
      ]
    ]
  }
}' &gt; commitlint.config.js
echo '{
  &quot;hooks&quot;: {
      &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;
    }
}' &gt; .huskyrc
</code></pre></div></li></ol></li></ul> <h2 id="为项目增加提交时eslint检查和修复"><a href="#为项目增加提交时eslint检查和修复" class="header-anchor">#</a> 为项目增加提交时Eslint检查和修复</h2> <p>​	⚠️只会校验和修复暂存区中的文件，如果想修复本地，可以执行<code>npx eslint --fix --ext .js,.jsx,.ts,.tsx,.vue src</code></p> <ol><li>安装依赖</li></ol> <div class="language-shell extra-class"><pre class="language-shell"><code>cnpm i lint-staged --save-dev
</code></pre></div><ol start="2"><li>生成配置文件<code>.lintstagedrc</code></li></ol> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">echo</span> <span class="token string">'{
  &quot;src/**/*.{js,jsx,txs,ts,vue}&quot;: &quot;eslint --fix&quot;
}'</span> <span class="token operator">&gt;</span> .lintstagedrc
</code></pre></div><ol start="3"><li><p>配置<code>.huskyrc</code>，增加预提交钩子</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token string">&quot;hooks&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>
	<span class="token string">&quot;pre-commit&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;lint-staged --no-stash&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>配置完成后，提交代码时会自动做Eslint检查和修复，此步骤如果无法通过则需要重新提交代码。</p> <ol><li>如有错误性 (errors) 问题，需要解决错误重新提交。</li> <li>如有提示性 (warning)问题（代码格式化），会自动修复并将修改暂存（只是暂存，还是需要重新提交代码）。</li></ol></li></ol></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/lei4519/blog/edit/master/src/technology/Git/Git book 笔记.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">最后更新时间:</span> <span class="time">9 个月前</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/technology/Electron/ipc.html" class="prev">
        Electron 进程通信
      </a></span> <span class="next"><a href="/blog/technology/HTTP/http2.html">
        HTTP 2
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.5a94629e.js" defer></script><script src="/blog/assets/js/3.98e048c5.js" defer></script><script src="/blog/assets/js/19.bdb46fb7.js" defer></script>
  </body>
</html>
